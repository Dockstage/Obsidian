---
creation_date: Sunday 12 January 2025 04:57:37
last_modified: Thursday, 22 May 2025, 04:26:21
---
# HTML
---
## Тема 1. Семантическая разметка
==Семантическая разметка== - это использование HTML-элементов таким образом, чтобы структура и смысл содержимого веб-страницы были понятны не только человеку, но и машинам (поисковым системам, программам чтения с экрана, другим сервисам). Как минимум, соблюдая семантику, мы улучшаем ==поисковую оптимизацию== (дает поисковым системам нужный контекст, помогает понять содержимое сайта и проиндексировать его относительно других со схожей тематикой). 

Если поговорить чуть подробнее про это, то **Поисковая оптимизация (SEO, Search Engine Optimization)** — это совокупность мер по улучшению видимости сайта в результатах поисковых систем (таких как Google, Яндекс, Bing). Цель SEO — повысить позиции сайта по определённым ключевым запросам, чтобы привлечь больше органического (бесплатного) трафика. То есть благодаря правильной семантике поисковые системы будут лучше продвигать сайт и среди результатов поисковых запросов он будет выше, чем остальные сайты.

- `<header>` - тег для выделения вводного содержимого или навигации. Не привязан к конкретному месту страницы или внутри её отдельного блока, но традиционно используется для создания - «шапки». Также можно использовать для оборачивания оглавления раздела, заголовка статьи с вводной информацией о ней и т. д.
  
- `<nav>` - контейнер для навигации со ссылками на другие страницы и разделы сайта. По традиции помещается в header или footer (не обязательно).
  
- `<main>` - контейнер для основного содержимого страницы.

- `<footer>` - тег с информацией о разделе. Например, это могут быть данные о том, когда была написана статья, её авторе и пр. Тоже не имеет жёсткой привязки к положению на странице или отдельной секции, к которой относится. По традиции часто одинаков на всех страницах сайта.

- `<article>` - тег для создания самостоятельных блоков контента. Его содержимое может быть карточкой статьи в блоге, карточкой товара, рекламным баннером и любым другим самодостаточным логическим блоком.

- `<section>` - логический контейнер для объединения содержимого по смыслу. Его часто путают с `<article>`. `<section>` используют для отделения одной смысловой части от другой, а `<article>` - самодостаточный контейнер со своим содержимым.

- `<aside>` - тег для дополнительного контента, используется для создания «сайдбара» или бокового меню на сайтах. Считается, что заключенная в aside информация не индексируется поисковыми системами.
---
## Тема 2. Блочные и строчные теги
Выделяют две основные категории HTML-элементов, которые соответствуют типам их содержимого и поведению в структуре веб-страницы — **блочные** и **строчные**. С помощью блочных элементов можно создавать структуру веб-страницы, строчные элементы используются для форматирования текстовых фрагментов (за исключением элементов `<area>` и `<img>`).

Разделение элементов на блочные и строчные используется в спецификации HTML до версии 4.01. В HTML5 эти понятия заменены более сложным набором [категорий контента](https://html5book.ru/kontentnaya-model-html5/), согласно которым каждый HTML-элемент должен следовать правилам, определяющим, какой контент для него допустим.

**1.  Модель визуального форматирования**

HTML-документ организован в виде дерева элементов и текстовых узлов. Модель визуального форматирования CSS представляет собой алгоритм, который обрабатывает HTML-документ и выводит его на экран устройства.

Каждый блок в дереве представляет соответствующий элемент или псевдоэлемент, а текст (буквы, цифры, пробелы), находящийся между открывающим и закрывающим тегами, представляет содержимое текстовых узлов.

Чтобы создать дерево блоков, CSS сначала использует каскадирование и наследование, позволяющие назначить вычисленное значение для каждого css-свойства каждому элементу и текстовому узлу в исходном дереве.

Затем для каждого элемента CSS генерирует ноль или более блоков в соответствии со значением свойства display этого элемента. Как правило, элемент генерирует один основной блок, который представляет самого себя и содержит свое содержимое. Некоторые значение свойства display, например, display: list-item;, генерируют блок основного блока и блок дочернего маркера. Другие, например, display: none;, приводят к тому, что элемент и/или его потомки вообще не генерируют блоки.

Положение блоков на странице определяется следующими факторами:

- размером элемента (с учётом того, заданы они явно или нет);
- типом элемента (строчный или блочный);
- схемой позиционирования (нормальный поток, позиционированные или плавающие элементы);
- отношениями между элементами в DOM (родительский — дочерний элемент);
- внутренними размерами содержащихся изображений;
- внешней информацией (например, размеры окна браузера).

**2.  Блочные элементы и блочные контейнеры**

**Блочные элементы** — элементы высшего уровня, которые форматируются визуально как блоки, располагаясь на странице в окне браузера вертикально. Значения свойства *display*, такие как *block*, *list-item* и *table* делают элементы блочными. Блочные элементы генерируют основной блок, который содержит только блок элемента. Элементы со значением *display: list-item* генерируют дополнительные блоки для маркеров, которые позиционируются относительно основного блока.

Блочные элементы могут размещаться непосредственно внутри элемента `<body>`. Они создают разрыв строки перед элементом и после него, образуя прямоугольную область, по ширине занимающую всю ширину веб-страницы или блока-родителя.

Блочные элементы могут содержать как строчные, так и блочные элементы, но не оба типа элементов сразу. При необходимости, строки текста, принадлежащие блочному контейнеру, могут быть обёрнуты анонимными контейнерами, которые будут вести себя внутри блока как элементы со значением *display: block;*, а строчные элементы обёрнуты элементом `<p>`. Блочные элементы могут содержаться только в пределах блочных элементов.

**Анонимные блоки уровня блока**

Как говорилось выше, блочные элементы могут содержать только блочные или только строчные элементы. В случае смешанного контента, когда блочный элемент одновременно содержит текстовое содержимое и другой блочный элемент, алгоритм визуального форматирования добавляет дополнительную обёртку для текстового содержимого — так называемый ==анонимный блок==. Анонимный блок не связан ни с одним элементом. Поскольку такой контейнер не имеет названия, то к нему нельзя применить CSS-стили для оформления. Анонимные блоки наследуют свойства окружающего блока, а не наследуемые свойства принимают первоначальное значение.

![[Anonym Blocks.png]]

**Таблица с самыми частыми ==блочными тегами== в HTML:**

| Тег            | Краткое описание                                                |
| -------------- | --------------------------------------------------------------- |
| `<address>`    | Определяет контактную информацию автора документа/статьи.       |
| `<artical>`    | Определяет текст как статью, новость и др.                      |
| `<aside>`      | Определяет контент в стороне от содержимого страницы.           |
| `<blockquote>` | Выделяет текст с другого источника, как блочную цитату.         |
| `<dd>`         | Cоздает описание элемента в списке определений.                 |
| `<div>`        | Определяет раздел документа.                                    |
| `<dl>`         | Создает список определений.                                     |
| `<dt>`         | Oпределяет термин в списке определений.                         |
| `<figure>`     | Группирует элементы страницы.                                   |
| `<footer>`     | Нижняя часть документа.                                         |
| `<form>`       | Определяет HTML форму.                                          |
| `<h1> - <h6>`  | Определяют HTML заголовки.                                      |
| `<header>`     | Задает "шапку" сайта или раздела.                               |
| `<hr>`         | Создает горизонтальную линию.                                   |
| `<li>`         | Определяет элемент списка.                                      |
| `<nav>`        | Определяет группу ссылок для навигации.                         |
| `<ol>`         | Создает нумерованный(упорядоченный) список.                     |
| `<p>`          | Определяет абзац.                                               |
| `<pre>`        | Оставляет содержимое в первоначальном виде.                     |
| `<ruby>`       | Определяет небольшую аннотацию (для типографии Восточной Азии). |
| `<section>`    | Определяет разделы документа.                                   |
| `<table>`      | Создает таблицу.                                                |
| `<tr>`         | Создает строку в таблице.                                       |
| `<ul>`         | Определяет маркированный(неупорядоченный) список.               |

**3.  Строчные элементы и строчные контейнеры

**Встроенные (строчные) элементы** генерируют внутристрочные контейнеры. Они не формируют новые блоки контента. Значения свойства *display*, такие как *inline* и *inline-table* делают элементы строчными.

Строчные элементы могут содержать только данные и другие строчные элементы. Исключение составляет элемент `<a>`, который согласно спецификации HTML5 может оборачивать целые абзацы, списки, таблицы, заголовки и целые разделы при условии, что они не содержат другие интерактивные элементы — другие ссылки и кнопки.

**Анонимные блоки уровня строки**

Любой текст, содержащийся непосредственно внутри блочного элемента и не внутри строчного элемента, рассматривается как анонимный строчный элемент. Также как и анонимные блоки уровня блока они наследуют свойства родительского блока, а не наследуемые свойства принимают первоначальное значение.

![[Anonym Blocks2.png]]


**Особенности строчных элементов:**

- Внутрь строчных элементов допустимо помещать текст или другие строчные элементы. Вставлять блочные элементы внутрь строчных запрещено.
  
- Эффект схлопывания отступов не действует: если у первого элемента отступ (margin) снизу 20px, а у второго элемента отступ (margin) сверху 30px, то между ними будет отступ 30px, а не 50px. Применяется только к вертикальным отступам (margin) блочных элементов. Выбирается наибольшее значение).
  
- Свойства, связанные с размерами (width, height) не применимы.
  
- Ширина равна содержимому плюс значения отступов, полей и границ. 
  
- Несколько строчных элементов, идущих подряд, располагаются на одной строке и переносятся на другую строку при необходимости.

**Таблица с самыми частыми ==строчными тегами== в HTML:**

| Тег          | Краткое описание                                                                          |
| ------------ | ----------------------------------------------------------------------------------------- |
| `<a>`        | Создает гиперссылку.                                                                      |
| `<abbr>`     | Определяет текст как аббревиатуру.                                                        |
| `<audio>`    | Определяет звуковое содержимое.                                                           |
| `<b>`        | Выделяет текст жирным шрифтом.                                                            |
| `<bdo>`      | Определяет направление отображения текста.                                                |
| `<button>`   | Создает кнопку.                                                                           |
| `<canvas>`   | Определяет область для рисования графиков.                                                |
| `<cite>`     | Определяет заголовок для работы - преобразует текст в курсивный.                          |
| `<code>`     | Определяет кусок программного кода - преобразует текст в моноширинный.                    |
| `<del>`      | Определяет текст, который был удален из документа - отображается перечеркнутым текстом.   |
| `<dfn>`      | Выделяет определения термина - преобразует шрифт в наклонный.                             |
| `<em>`       | Определяет выделенный текст - преобразует текст в курсивный.                              |
| `<i>`        | Преобразует текст в курсивный.                                                            |
| `<iframe>`   | Определяет встроенный frame.                                                              |
| `<img>`      | Определяет изображение.                                                                   |
| `<input>`    | Создаeт поле для ввода данных.                                                            |
| `<ins>`      | Определяет текст, который был добавлен в документ - отображает текст подчеркнутым.        |
| `<kbd>`      | Определяет текст вводимый с клавиатуры - преобразует текст в моноширинный.                |
| `<mark>`     | Определяет важную часть текста.                                                           |
| `<meter>`    | Определяет скалярное измерение в пределах известного диапазона.                           |
| `<q>`        | Определяет короткую цитату.                                                               |
| `<rp>`       | Определяет, что показывать браузеру, который не поддерживает тег `<ruby>`.                |
| `<rt>`       | Добавляет аннотацию сверху или снизу от символов, заключенных в элементе `<ruby>`.        |
| `<s>`        | Определяет текст, который больше не является правильным - отображает текст перечеркнутым. |
| `<samp>`     | Определяет текст, который является результатом вывода компьютерной программы.             |
| `<small>`    | Определяет текст маленького размера.                                                      |
| `<select>`   | Создает выпадающий список.                                                                |
| `<span>`     | Определяет строчный элемент документа.                                                    |
| `<strong>`   | Определяет важный текст - преобразует шрифт в полужирный.                                 |
| `<sub>`      | Определяет текст в нижнем индексе.                                                        |
| `<sup>`      | Определяет текст в верхнем индексе.                                                       |
| `<td>`       | Создает ячейку таблицы.                                                                   |
| `<textarea>` | Создает многострочное текстовое поле.                                                     |
| `<th>`       | Создает заголовочную ячейку в таблице.                                                    |
| `<var>`      | Определяет переменную - выделяет текст курсивом.                                          |
| `<video>`    | Добавляет на страницу видео файл.                                                         |
**4.  Строчно-блочные элементы** 

Стоит сказать для начала, что эти элементы всё также являются строчными элементами, но по умолчанию у них стоит *display: inline-block*. Эти элементам, в отличии от обычных строчных элементов, можно задавать поля, отступы, ширину и высоту. К ним относятся:

- `<audio>`
- `<button>`
- `<canvas>`
- `<embed>`
- `<input>`
- `<keygen>`
- `<meter>`
- `<object>`
- `<progress>`
- `<select>`
- `<textarea>`
- `<video>`

## Тема 3. Контентная модель HTML5
HTML-элементы до 5 версия языка HTML делились только на ***block-level elements***(блочные элементы) и ***inline-level elements*** (строчные элементы), о чём было расписано в прошлой теме. Блочные элементы ***(div, p, h1, h2 и др.)*** - это элементы, которые имеют своё собственное пространство в документе (прямоугольную область). Их основное назначение заключается в разметке веб-страницы на уровне блоков. Строчные элементы ***(inline-level elements)*** как правило находятся внутри блочных элементов. Они рассматриваются как текстовые элементы, и следовательно, отображаются как обычный поток текста. Назначение строчных элементов - это разметка веб-страницы на уровне строк.

В HTML 5 модели определения контента были расширены для того, чтобы с помощью них можно было более точно описать различные типы контента, с которыми могут столкнуться авторы при создании HTML-документа.

Эти модели позволяют пользовательским агентам (user agent) более точно определить, какой тип контента следует ожидать внутри элемента. Это позволит контролировать некоторые аспекты синтаксиса. Например, какие элементы могут быть вложены в некоторый элемент и др.

Изучение этих типов контента позволит лучшее понимать синтаксис технологии HTML5 и то как одни элементы связаны с другими. Каждый элемент согласно спецификации HTML 5 должен использоваться в соответствии с контентной моделью.

> Контентная модель - это набор правил, которые определяют можно ли использовать некоторый HTML-элемент в некотором контенте или нет.

На следующем изображении показаны **модели контента спецификации HTML 5**

![[Content Model HTML5.png]]

Каждый элемент в HTML принадлежит ноль или более категориям, которые группируют элементы со схожими характеристиками. Выделяют следующие общие категории:

- Потоковое содержимое (Flow content)
- Мета содержимое (Metadata content)
- Секционное содержимое (Sectioning content)
- Заголовочное содержимое (Heading content)
- Текстовое содержимое (Phrasing content)
- Встроенное содержимое (Embedded content)
- Интерактивное содержимое (Interactive content)

Секционное, заголовочное, текстовое, встроенное и интерактивное содержимое относятся к потоковому содержимому. Мета содержимое иногда может относиться к потоковому содержимому. Мета содержимое и интерактивное содержимое иногда относятся к текстовому содержимому. Встроенное содержимое также относится к текстовому содержимому, но часть элементов также является интерактивным содержимым.

Другие категории используются для специфических целей, например, для определения элементов форм. Некоторые элементы имеют уникальные требования и не вписываются в какую-либо конкретную категорию.

**1.  Потоковое содержимое**

Контент типа flow включает в себя большинство элементов HTML 5. В этой категории представлены элементы с которыми обычно приходиться сталкиваться при создании HTML-документа.

Flow контент должен находиться в элементе body, т.к. именно его содержимое определяет поток, который будет выводиться в рабочую область окна или вкладки браузера. Важно отметить ещё то, что если контент представлен как flow, то это ни каким образом не влияет на отображение элемента в браузере (пользовательском агенте).

Flow контент является основным, в некотором смысле родительским контентом, который может содержать более специализированное содержание.

HTML-элементы, принадлежащие к ***flow контенту***:
- `<a>` 
- `<abbr>` 
- `<address>` 
- `<area>` (если он является потомком элемента `<map>`)
- `<article>`
- `<aside>`
- `<audio>` 
- `<b>` 
- `<bdi>` 
- `<bdo>` 
- `<blockquote>` 
- `<br>`
- `<button>`
- `<canvas>`
- `<cite>`
- `<code>` 
- `<data>`
- `<datalist>`
- `<del>`
- `<details>`
- `<dfn>`
- `<dialog>`
- `<div>`
- `<dl>`
- `<em>`
- `<embed>`
- `<fieldset>`
- `<figure>`
- `<footer>`
- `<form>`
- `<h1>-<h6>`
- `<header>`
- `<hr>`
- `<i>`
- `<iframe>`
- `<img>`
- `<input>`
- `<ins>`
- `<kbd>`
- `<label>`
- `<link>` (если его присутствие внутри тела документа допускается)
- `<main>` 
- `<map>`
- `<mark>`
- `<math>` 
- `<menu>` 
- `<meter>` 
- `<nav>` 
- `<noscript>` 
- `<object>` 
- `<ol>` 
- `<output>` 
- `<p>` 
- `<picture>` 
- `<pre>` 
- `<progress>` 
- `<q>` 
- `<ruby>` 
- `<s>` 
- `<samp>` 
- `<script>` 
- `<section>` 
- `<select>` 
- `<small>` 
- `<span>` 
- `<strong>` 
- `<sub>` 
- `<sup>` 
- `<svg>` 
- `<table>` 
- `<template>` 
- `<textarea>` 
- `<time>`
- `<u>` 
- `<ul>` 
- `<var>` 
- `<video>` 
- `<wbr>`

**2.  Мета содержимое**

***Metadata (метаданные)*** представляют из себя контент, который определяет внешний вид или поведение остального контента на веб-странице, а также используется для установления связи с другими документами. Элементы из этой категории в основном используются в элементе head документа. Следует обратить внимание на то, что область контента metadata частично перекрывает область контента flow. Это указывает на то, что определённый контент, например, script может быть использован как в секции metadata, так и в секции flow документа.

HTML-элементы, принадлежащие к ***metadata контенту***:
- `<base>`
- `<link>` 
- `<meta>` 
- `<noscript>` 
- `<script>` 
- `<style>` 
- `<template>` 
- `<title>`

**3.  Секционное содержимое**

Данный контент используется для создания разделов, которые определяют область заголовков и футеров. 

HTML-элементы, принадлежащие к ***sectioning контенту***:
- `<article>`
- `<aside>`
- `<nav>`
- `<section>`

**4.  Заголовочное содержимое**

Категория heading определяет заголовки разделов, которые могут быть либо размечены явно с помощью элементов sectioning или просто подразумеваться ими.

HTML-элементы, принадлежащие к ***heading контенту***:
- `<h1>`
- `<h2>` 
- `<h3>` 
- `<h4>` 
- `<h5>` 
- `<h6>`

**5.  Текстовое содержимое**

***Phraising контент*** - это текст документа, а также элементы, которые используются для разметки этого текста. Во многих отношениях phraising контент является тем же элементом inline из спецификации HTML4.

Phrasing контент является частью контента flow. Большинство элементов из этой категории могут содержать в качестве своего контента только элементы из своей собственной категории. Т.е. в содержимое этих элементов нельзя включать любой элемент из контента flow.

HTML-элементы, принадлежащие к ***phraising контенту***:
- `<a>` 
- `<abbr>` 
- `<area>` (если он является потомком элемента map) 
- `<audio>` 
- `<b>` 
- `<bdi>` 
- `<bdo>` 
- `<br>` 
- `<button>` 
- `<canvas>` 
- `<cite>`
- `<code>`
- `<data>`
- `<datalist>`
- `<del>` 
- `<dfn>`
- `<em>`
- `<embed>` 
- `<i>`
- `<iframe>`
- `<img>`
- `<input>`
- `<ins>`
- `<kbd>`
- `<keygen>`
- `<label>`
- `<map>`
- `<mark>`
- `<math>`
- `<meter>`
- `<noscript>`
- `<object>`
- `<output>`
- `<progress>`
- `<q>`
- `<ruby>`
- `<s>`
- `<samp>`
- `<script>`
- `<select>`
- `<small>`
- `<span>`
- `<strong>`
- `<sub>`
- `<sup>`
- `<svg>`
- `<template>`
- `<textarea>`
- `<time>`
- `<u>`
- `<var>`
- `<video>`
- `<wbr>`
- `<text>`

**6.  Встроенное содержимое**

Embedded content — содержимое, которое импортируется в документ из других источников, другого языка разметки или пространства имён. Некоторые элементы могут иметь резервный контент, который будет задействован, если внешний ресурс не может быть использован (например, в случае неподдерживаемого формата видео).

Embedded контент является частью контента Phrasing. В тоже время часть контента Embedded является частью контента Interactive.

HTML-элементы, принадлежащие к этой категории:
- `<audio>` 
- `<canvas>` 
- `<embed>` 
- `<iframe>` 
- `<img>` 
- `<math>` 
- `<object>` 
- `<picture>` 
- `<svg>` 
- `<video>`

**7.  Интерактивное содержимое**

Interactive контент - это контент, специально предназначенный для взаимодействия с пользователем. В модели контента часть области категории interactive пересекается с областями категорий embedded и phrasing. Это означает то, что некоторые HTML-элементы могут относится сразу к нескольким этим категориям.

HTML-элементы, принадлежащие к interactive контенту:
- `<a>` 
- `<audio>` (если присутствует атрибут controls) 
- `<button>` 
- `<embed>`
- `<iframe>` 
- `<img>` (если присутствует атрибут usemap)
- `<input>` (если значение атрибут type не hidden)
- `<keygen>`
- `<label>`
- `<object>` (если присутствует атрибут usemap)
- `<select>`
- `<textarea>`
- `<video>` (если присутствует атрибут controls)

***Дополнительные категории содержимого***

1) **Явное содержимое**
   Как правило, элементы, принадлежащие модели потокового или текстового содержимого, должны иметь минимум один узел, который имеет явное содержимое и для него не задан атрибут *hidden*. Явное содержимое делает элемент непустым. Это обеспечивается тем, что элемент содержит потомка с текстом или каким-либо содержимым, которое пользователь может слышать (элемент `<audio>`), видеть (элемент `<canvas>`, `<img>` или `<video>`) или каким-либо образом взаимодействовать с ним (интерактивные элементы форм).

   Это требование не является жёстким, так как в некоторых случаях элемент может быть пустым по очевидным причинам (например, он в последствии будет наполняться с помощью скрипта).

   - `<a>` 
   - `<abbr>` 
   - `<address>` 
   - `<article>` 
   - `<aside>` 
   - `<audio>` (если присутствует атрибут controls)
   - `<b>` 
   - `<bdi>` 
   - `<bdo>` 
   - `<blockquote>` 
   - `<button>` 
   - `<canvas>` 
   - `<cite>` 
   - `<code>` 
   - `<data>` 
   - `<details>` 
   - `<dfn>` 
   - `<div>` 
   - `<dl>` (если он содержит по крайней мере одну пару термин описание) 
   - `<em>` 
   - `<embed>` 
   - `<fieldset>` 
   - `<figure>` 
   - `<footer>` 
   - `<form>` 
   - `<h1 - h6>` 
   - `<header>` 
   - `<i>` 
   - `<iframe>` 
   - `<img>` 
   - `<input>` (если значение атрибута type не равно hidden) 
   - `<ins>` 
   - `<kbd>` 
   - `<label>` 
   - `<main>` 
   - `<map>` 
   - `<mark>` 
   - `<math>` 
   - `<menu>` (если значение атрибута type равно toolbar) 
   - `<meter>`
   - `<nav>` 
   - `<object>` 
   - `<ol>` (если он содержит по крайней мере один элемент `<li>`) 
   - `<output>` 
   - `<p>` 
   - `<pre>` 
   - `<progress>` 
   - `<q>` 
   - `<ruby>` 
   - `<s>` 
   - `<samp>` 
   - `<section>` 
   - `<select>` 
   - `<small>` 
   - `<span>` 
   - `<strong>` 
   - `<sub>` 
   - `<sup>` 
   - `<svg>` 
   - `<table>` 
   - `<textarea>` 
   - `<time>` 
   - `<u>` 
   - `<ul>` (если он содержит по крайней мере один элемент `<li>`) 
   - `<var>` 
   - `<video>` текст, не являющийся пробелом между элементами

2) **Элементы, поддерживающие скрипт**
   Элементы, поддерживающие скрипт, не отображаются на экране. Они используются для поддержки сценариев, например, для обеспечения функциональных возможностей для пользователя.

   - `<script>` 
   - `<template>`
 
3) **Корневое секционное содержимое**
   Кроме секционного содержимого есть несколько элементов, являющихся корневыми секционными. Они выделены из секционного содержимого, но также могут иметь собственную структуру заголовков, а разделы и заголовки внутри этих элементов не взаимодействуют со структурой заголовков их родителей.

   - `<blockquote>` 
   - `<body>` 
   - `<details>` 
   - `<dialog>` 
   - `<fieldset>` 
   - `<figure>` 
   - `<td>`

4) **Прозрачная модель содержимого**
   Некоторые элементы имеют прозрачную модель содержимого. Это означает, что тип ожидаемого содержимого наследуется от их родительского элемента. Дополнительно к собственному разрешенному контенту они могут содержать любой контент, который допустим для их родительского элемента. Если такой элемент не имеет родительского элемента, то его прозрачная модель контента должна рассматриваться как ожидающая любое содержимое из категории потокового содержимого.

   - `<a>` 
   - `<audio>`
   - `<canvas>` 
   - `<del>` 
   - `<ins>` 
   - `<map>` 
   - `<object>` 
   - `<video>`






## Тема 4. Теги для форматирования текста (p, h1-h6, span, br, hr)

**1.  Тег `<p>` (от "paragraph")**

Данный тег определяет текстовый абзац. Является блочным элементом, всегда начинается с новой строки.

Если закрывающего тега нет, считается, что конец абзаца совпадает с началом следующего блочного элемента.

Абзацы текста, идущие друг за другом, разделяются между собой отбивкой (автоматически определяемыми отступами). Величиной отбивки можно управлять с помощью стилей.

Что касается *атрибутов*, то у тега `<p>` есть *"align": {left, center, right, justify (выравнивание по ширине)}*. В зависимости от выбранного значения атрибута, мы можем позиционировать текст внутри тега `<p>`.

**2.  Тег h1-h6 (от "heading")**

Так, тег `<h1>` представляет собой наиболее важный заголовок первого уровня, а тег `<h6>` является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Это **блочный тег**. Закрывать обязательно.

*Заголовки очень «любят» поисковые системы*.

**3.  Тег span (англ. "отрезок")**

Тег `<span>` предназначен для *определения строчных элементов* документа. В отличие от блочных элементов, таких как `<table>`, `<p>` или `<div>`, с помощью тега `<span>` можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега `<p>`) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.

**4.  Тег br (от "break")**

Тег `<br>` устанавливает перевод строки в том месте, где этот тег находится. В отличие от тега абзаца `<p>`, использование тега `<b>` не делает "отбивки" (не добавляет пустой отступ перед строкой). Закрывающий тег `</br>` не обязателен.

**5.  Тег hr (от "horizontal rule")**

Рисует такую горизонтальную линию, которая по своему виду зависит от используемых параметров, а также браузера:

---
Тег `<hr>` относится к блочным элементам, линия всегда начинается с новой строки, а после нее все элементы отображаются на следующей строке. Поэтому его нельзя вставлять внутрь абзаца или другого текстового контента (непредсказуемое поведение). *Одиночный тег (закрывать не обязательно)*. Есть атрибуты для стилизации: *"size", "color", " width", "alighn"*.

## Тема 5. Теги для выделения текста (strong, b,  em, i, u, blockquote, q, sup, sub)

**1.  Тег strong (англ. "строгий")**

Тег **предназначен для акцентирования текста**. Браузеры отображают такой текст жирным начертанием. Закрывающий тег обязателен.

**2.  Тег b (от "bold")**

Устанавливает **жирное начертание шрифта.** Закрывающий тег обязателен. В настоящее время *используется редко*. Более приемлемый вариант - *стилизация средствами CSS*. 

Разница между тегами `<b>` и `<strong>` состоит в том, что `<b>` относится к тегам *физической разметки*, то есть благодаря нему происходит сам факт того, что буквы становятся жирными. `<strong>` же относится к тегам *логической разметки*, то есть он определяет важность помеченного текста, чтобы люди акцентировали внимание на нём.

**3.  Теги em (от "emphasis") и i (от "italic")**

Ситуация крайне схожа с тегами `<b>` и `<strong>`. 

Тег `<em>` определяет текст, на который сделан особый _акцент_, меняющий смысл предложения. Закрывающий тег обязателен. 

Тег `<i>` применяется для обозначения текста, который _отличается_ от окружающего текста, но не является более важным. Закрывающий тег обязателен.

Но опять таки, в настоящее время более приемлемый вариант - *стилизация средствами CSS*.

**4.  Тег u (от "underline")**

Добавляет <u>подчеркивание</u> к тексту. Этот тег осуждается спецификацией HTML, взамен *рекомендуется использовать стили*. Закрывающий тег обязателен.

**5.  Тег blockquote**

Тег `<blockquote>` предназначен для выделения длинных цитат внутри документа. Текст, обозначенный этим тегом, традиционно отображается как выровненный блок с отступами слева и справа (примерно по 40 пикселей), а также с отбивкой сверху и снизу.

**Аналога в CSS нет**. Но реализовать средствами CSS можно

**6.  Тег q (от "quote")**

Тег используется для выделения в тексте цитат. Содержимое контейнера автоматически отображается в браузере в кавычках. Закрывающий тег обязателен.

**7.  Теги sup и sub (от "superscript" и "subscript")**

Тег `<sup>` отображает шрифт в виде <sup>верхнего индекса</sup>. Шрифт при этом отображается выше базовой линии текста и уменьшенного размера.

Тег `<sub>` отображает шрифт в виде <sub>нижнего индекса</sub>. Текст при этом располагается ниже базовой линии остальных символов строки и уменьшенного размера.

Закрывающие теги у них обязательны.


## Тема 6. Теги для списков (ul, ol, li)

Для создания **нумерованных** и **маркированных** списков используются теги `<ol>` и `<ul>`, в которых каждый пункт списка находится в теге `<li>`. Между номером (маркером) списка и элементом списка автоматически устанавливается отбивка (отступ). 

**Нумерованный список** - это список, в котором каждый пункт стоит под порядковым номером (числом, буквой):

1. Яблоко
2. Груша
3. Айва

**Маркированный (ненумерованный) список -** это список, в котором каждый пункт отмечен не цифрой, а маркером:

- Яблоко
- Груша
- Айва

**Внутри ol и ul могут быть только элементы списка li!**

Внутри li может быть любой элемент, как строчный, так и блочный:
<ul>
      <li><a href="#">Главная</a></li>
      <li><a href="#">Блог</a></li>
      <li><a href="#">Новости</a></li>
</ul>
Закрывающие теги обязательны.

У тега `<ol>` есть несколько атрибутов:
- **type** = {"1", "A", "a", I, i }  - устанавливает вид маркера списка (использование этого атрибута осуждается спецификацией HTML).

- **reversed** - нумерация в списке становится по убыванию (3,2,1).

- **start** - задаёт число, с которого будет начинаться нумерованный список.

```html
<ul>
      <li>
        Тег type - устанавливает вид маркера списка (использование этого
        атрибута осуждается спецификацией HTML):
      </li>
      <li>
        <ol type="1">
          <!--Применяется по умолчанию-->
          <li>Зима</li>
          <li>Весна</li>
          <li>Лето</li>
          <li>Осень</li>
        </ol>
        <hr />
        <ol type="A">
          <li>Понедельник</li>
          <li>Вторник</li>
          <li>Среда</li>
        </ol>
        <hr />
        <ol type="a">
          <li>Вася</li>
          <li>Маша</li>
          <li>Зина</li>
        </ol>
        <hr />
        <ol type="I">
          <li>Январь-март</li>
          <li>Апрель-Июнь</li>
          <li>Июль-сентябрь</li>
          <li>Октябрь-декабрь</li>
        </ol>
        <hr />
        <ol type="i">
          <li>Зима</li>
          <li>Весна</li>
          <li>Лето</li>
          <li>Осень</li>
        </ol>
      </li>
      <hr />
      <li>
        Атрибут <b>reversed</b> - нумерация в списке становится по убыванию
        (3,2,1).
      </li>
      <li>
        <ol reversed>
          <!--Синтаксис!-->
          <li>Удовлетворительно</li>
          <li>Хорошо</li>
          <li>Отлично</li>
        </ol>
        <hr />
      </li>
      <li>
        Атрибут <b>start</b> - задаёт число, с которого будет начинаться
        нумерованный список.
      </li>
      <li>
        <ol type="a" start="4">
          <li>Апрель</li>
          <li>Май</li>
          <li>Июнь</li>
        </ol>
        <hr />
      </li>
    </ul>
```

В тег `<li>` мы также можем *вставлять другие списки

**Атрибут тега ul**
- **type** = {"disk", "circle", "square"}

```html
<ul>
    <li type="disc">Франция</li>
    <!--type disc - по умолчанию-->
    <li>Германия</li>
    <li type="circle">Турция</li>
    <li type="square">Испания</li>
</ul>
```

Атрибуты, предназначенные для тега `<ol>`, у тега `<ul>` тоже срабатывают (хотя это странно, `<ul>` всё же ненумерованный список)

```html
 <ul>
    <li type="a" value="3">Швеция</li>
    <li type="1" value="2">Финляндия</li>
 </ul>
```

**Наследование**

`<li>` - т.н. дочерний элемент в стилизации. То есть, он наследует свойства родителей. Теги `<ol>` и `<ul>` считаются родительскими по отношению к тегу `<li>`. 

**Стилизацию списков намного предпочтительнее осуществлять с помощью CSS**

```html
<style>
.menu {
      font-family: Arial, sans-serif;
      list-style-type: none;
      margin: 30px;
      padding: 0;
      background-color: #1205c7;
      display: flex;
      justify-content: space-between;
    }
    .menu-item {
      flex: 1;
    }
    .menu-item a {
      display: block;
      color: white;
      text-align: center;
      padding: 14px 16px;
      text-decoration: none;
    }
    .menu-item a:hover {
      background-color: red;
    }
</style>

<ul class="menu">
    <li class="menu-item"><a href="#home">Главная</a></li>
    <li class="menu-item"><a href="#products">Товары</a></li>
    <li class="menu-item"><a href="#prices">Цены</a></li>
    <li class="menu-item"><a href="#order">Заказать</a></li>
    <li class="menu-item"><a href="#profile">Профиль</a></li>
</ul>
```

Ну и не забываем о том, что `<ol>`, `<ul>` и `<li>` - блочные элементы









## Тема 7. Emmet

Ну, объективно говоря, я не вижу никакого смысла конспектировать эту тему, просто оставлю здесь две ссылки, который помогут разобраться в этом полезном инструменте

1) Теория по Emmet: https://dwstroy.ru/stail/plaginy-rasshireniya/emmet-shpargalka/
   
2) Онлайн-тренажёр по Emmet: https://epixx.github.io/emmet/


## Тема 8. Ссылки и кнопки

Начнём с **ссылок**

Ссылки бывают двух типов: 

1) **Простые**
   `<a href="index.html">Главная</a>`
   
   Тут рассказывать особо нечего. Простой тип ссылок требуется, в основном, для навигации по сайту.
   
   Для того, чтобы ссылка открывалась в отдельной вкладке, необходимо атрибуту "target" присвоить значение "_blank".
   
2) **Якорные**(закладки внутри страницы, которую можно указать в качестве цели ссылки)
   `<a href="#id">Вверх</a>`
   
   Чтобы сделать якорную ссылку, необходимо той ссылке, которая отвечает за закладку внутри страницы, в атрибуте "href" вписать идентификатор, принадлежащий тегу, к которому мы хотим переместиться

Адрес простой ссылки может быть **абсолютным** и **относительным**. 

*Абсолютные адреса* работают везде, вне зависимости от имени сайта или веб-страниц, где прописана ссылка. К абсолютным видам ссылок относятся все ссылки из Интернета.

Чаще всего придётся работать с *относительными* ссылками, которые используются для навигации по сайту. Это ссылки по типу "index.html". 

Теперь поговорим про **кнопки**.

Кнопки создаются при помощи тега `<button></button>`. На кнопке можно размешать любые *строчные* элементы, потому что сама кнопка также является строчным элементом.

**В чём различие между кнопкой и ссылкой?**

Действительно, иногда бывает так, что ссылку и кнопку тяжело отличить, как например тут:

![[Button vs Link.png]]

Но первый элемент является кнопкой, а второй ссылкой:

![[Button and Link.png]]

И разница между ними действительно есть, а именно она заключается в их функциональном предназначении: ссылка используется для навигации, а кнопка для выполнения какой-то функции (отправки данных, выполнения скрипта и так далее). 

Также, теоретически тег `<button>` должен находиться внутри формы, устанавливаемой тегом `<form>`. Но, тем не менее, браузеры не выводят сообщение об ошибке и корректно работают с тегом `<button>`, если он встречается самостоятельно. ОДНАКО если необходимый результат нажатия на кнопку отправить на сервер, то тег `<form>` обязателен. 


## Тема 9. Изображения

Итак, за изображения отвечает тег `<img>`. У этого следующие *атрибуты*:

- *src* - является обязательным и указывает на путь к изображению, которое необходимо отобразить на странице. Это может относительный или абсолютный путь к файлу изображения
  
- *alt* - позволяет указать альтернативный текст, который будет отображаться, если изображение не может быть загружено. Он также используется для улучшения доступности веб-сайта для пользователей с ограниченными возможностями, использующим экранные читалки, понять содержание изображения. Также поисковые системы используют этот атрибут, чтобы понять содержание изображения, что может помочь в поисковой оптимизации сайта. 
  
- *title* - добавляет всплывающую подсказку, которая отображается при наведении курсора на изображение. Это полезно для предоставления дополнительной информации об изображении
  
- *width, height* - размеры изображения в пикселях
  
- *class, id* - классы и ID для стилизации изображения 
  
- *loading*={lazy, eager, auto} - атрибут, который управляет загрузкой изображения
	- *lazy* - асинхронная загрузка по мере надобности изображения
	- *eager* - загрузка элемента немедленно
	- *auto* — порядок загрузки по усмотрению браузера (Если значение для атрибута loading не указано, браузер воспримет его как *auto*)
	  
- *align* - расположение изображения относительно страницы


**Достоинства и недостатки форматов изображений**

1. **JPEG(JPG)**
   Отлично подходит для фотографий и реалистичных изображений благодаря возможности высокой степени сжатия при минимальной потере качества. Однако ограничен в поддержке прозрачности. Касаемо сжатия стоит уточнить: **JPEG действительно сжимает изображение с потерями**. Это значит, что часть данных **навсегда удаляется**, чтобы уменьшить размер файла. Но суть в том, как именно это делается. Сжатие работает "умно": алгоритм JPEG старается убирать ту информацию, которую человеческий глаз меньше всего замечает — мелкие детали, небольшие цветовые переходы и т.п. При умеренном сжатии (например, 70–90% качества) разница почти незаметна. Фотография будет выглядеть так же, как оригинал — особенно на экране или в интернете. Но при сильном сжатии (например, 30–50%) качество падает — появляются артефакты, размытые границы, «лесенка» на краях, искажение цветов. А при **каждом новом сохранении** JPEG изображение сжимается заново, и **качество постепенно ухудшается**.
   
2. **SVG**
   Это векторный формат, который отлично масштабируется без потери качества, поэтому особенно подходит для логотипов, иконок, инфографики и других графических элементов, которые должны выглядеть чётко при любом размере. SVG-файлы, как правило, имеют небольшой вес и могут быть анимированы с помощью CSS или JavaScript. Однако формат не подходит для хранения фотографий или сложных реалистичных изображений. Также при неправильной обработке может представлять угрозу безопасности на веб-сайтах (например, XSS-атаки).
   
3. **PNG**
   Формат без потерь, что делает его хорошим выбором для изображений с чёткими границами, текстами, логотипами и скриншотами. Поддерживает прозрачность, включая альфа-канал, благодаря чему широко используется в веб-дизайне. Однако файлы PNG при высоком качестве могут быть значительно более объёмными по сравнению с JPEG, а сам формат не поддерживает анимацию (исключение — расширение APNG).
   
4. **GIF**
   Формат, идеально подходящий для создания простых анимированных изображений. 
   Он широко поддерживается и остаётся популярным в интернете, особенно для мемов, иконок и анимаций. Однако GIF ограничен 256 цветами, что делает его непригодным для реалистичных изображений. Размер файлов может быть большим при длительной или детализированной анимации, а сам формат считается устаревшим по сравнению с современными альтернативами.
   
5. **WebP**
   Современный формат от Google, объединяющий преимущества JPEG и PNG. Он поддерживает как сжатие с потерями, так и без потерь, умеет сохранять прозрачность и анимацию. При этом WebP обеспечивает меньший размер файла при сопоставимом качестве, что делает его привлекательным для веб-разработки. Тем не менее, формат не поддерживается некоторыми старыми браузерами и может быть медленнее при кодировании.
   
6. **AVIF**
   Ещё один современный формат, предлагающий отличное сжатие и качество. Он поддерживает прозрачность, анимацию и способен создавать изображения меньшего размера, чем даже WebP, при сохранении высокого визуального качества. Однако AVIF пока ещё не получил повсеместной поддержки, а его кодирование и декодирование требуют больших вычислительных ресурсов.


## Тема 10. Таблицы

Начнём с тегов, которые используются для создания таблиц.

- `<table>` - основной тег, обозначающий начало таблицы. У этого тега есть несколько *атрибутов*:
	- *border* - устанавливает толщину границы таблицы в пикселях
	- *cellpadding* - задаёт отступ между содержимым ячейки и ее границами
	- *cellspacing* - определяет расстояние между ячейками таблицы
	- *width* - позволяет установить ширину всей таблицы.
	  
- `<tr>` и `<td>` - используются для создания строк (`<tr>`) и ячеек (`<td>`) внутри таблицы. Внутри тега `<tr>` размещаются ячейки `<td>`. Тег `<td>` cоздаёт ячейку таблицы. Внутри ячейки может размещаться текст, изображения, списки и другие HTML-элементы.
  
- `<th>` - тег для обозначения заголовочных ячеек, отображаемых жирным шрифтом
  
- `<thead>` и `<tbody>` - используются для структурирования таблицы, разделяя её на заголовок (`<thead>`) и тело (`<tbody>`). Тег `<tbody>` используется для группировки строк таблицы в тело. Он является дополнительным, но рекомендуется для семантически верной разметки таблиц. Тег `<tbody>` позволяет отделить заголовок таблицы (`<thead>`) и колонтитулы (`<tfoot>`) от основного контента, что улучшает доступность и упрощает форматирование. Внутри тега `<tbody>` размещаются строки `<tr>` с ячейками `<td>`. Это делает структуру таблицы более понятной и облегчает стилизацию с помощью CSS.

  Также у тегов `<td>` и `<th>` есть *два главных атрибута*:
	- *colspan* - позволяет объединить несколько столбцов в одну ячейку по горизонтали
	
	- *rowspan* - позволяет объединить несколько строк в одну ячейку по вертикали

Также есть возможность размещать одну таблицу внутри другой для создания более сложных макетов.

Но, на самом деле, как бы то ни было, но создание таблиц при помощи этих тегов уже не очень приветствуется. Лучше и правильнее будет сделать при помощи *grid*-а. Но про него будет расписано в части в CSS. 







# CSS